# Reporting Module for Forensic Analysis Toolkit

function Export-HTMLReport {
    param (
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Config,
        
        [Parameter(Mandatory = $true)]
        [string]$Title,
        
        [Parameter(Mandatory = $true)]
        [string]$Content,
        
        [Parameter(Mandatory = $true)]
        [string]$OutputFile
    )
    
    $css = @"
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        h1, h2, h3 { color: #2c3e50; }
        .container { max-width: 1200px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .header { background-color: #34495e; color: white; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .highlight { background-color: #ffffcc; }
        .suspicious { background-color: #ffdddd; }
        .normal { background-color: #ddffdd; }
        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #34495e; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .footer { margin-top: 20px; text-align: center; font-size: 0.8em; color: #7f8c8d; }
    </style>
"@
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    
    $html = @"
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>$Title</title>
        $css
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>$Title</h1>
                <p>Generated: $timestamp</p>
                <p>Memory Dump: $($Config.MemoryDump)</p>
            </div>
            
            <div class="content">
                $Content
            </div>
            
            <div class="footer">
                <p>Generated by Memory Forensics Toolkit - Powered by Volatility 3</p>
            </div>
        </div>
    </body>
    </html>
"@
    
    $html | Out-File -FilePath $OutputFile -Encoding utf8
    Write-Host "HTML report saved to: $OutputFile" -ForegroundColor Green
}

function Export-FullReport {
    param (
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Config
    )
    
    $reportDir = $Config.OutputDirectories["reports"]
    $reportFile = Join-Path $reportDir "full_report.html"
    
    $content = ""
    
    # System Information Section
    $content += "<div class='section'><h2>System Information</h2>"
    if ($Config.AnalysisResults.ContainsKey("system_info") -and $Config.AnalysisResults["system_info"].ContainsKey("windows.info")) {
        $sysInfo = Get-Content -Path $Config.AnalysisResults["system_info"]["windows.info"] -Raw
        $content += "<pre>$sysInfo</pre>"
    } else {
        $content += "<p>No system information available.</p>"
    }
    $content += "</div>"
    
    # Process Analysis Section
    $content += "<div class='section'><h2>Process Analysis</h2>"
    if ($Config.AnalysisResults.ContainsKey("processes")) {
        foreach ($plugin in $Config.AnalysisResults["processes"].Keys) {
            $pluginName = $plugin -replace "windows.", ""
            $pluginContent = Get-Content -Path $Config.AnalysisResults["processes"][$plugin] -Raw
            $content += "<h3>$pluginName</h3><pre>$pluginContent</pre>"
        }
    } else {
        $content += "<p>No process analysis data available.</p>"
    }
    $content += "</div>"
    
    # Add similar sections for other analysis categories
    # DLLs and Modules
    $content += "<div class='section'><h2>DLLs and Modules</h2>"
    if ($Config.AnalysisResults.ContainsKey("modules")) {
        foreach ($plugin in $Config.AnalysisResults["modules"].Keys) {
            $pluginName = $plugin -replace "windows.", ""
            $pluginContent = Get-Content -Path $Config.AnalysisResults["modules"][$plugin] -Raw
            $content += "<h3>$pluginName</h3><pre>$pluginContent</pre>"
        }
    } else {
        $content += "<p>No DLL/module analysis data available.</p>"
    }
    $content += "</div>"
    
    # Malware/Memory Analysis
    $content += "<div class='section'><h2>Malware/Memory Analysis</h2>"
    if ($Config.AnalysisResults.ContainsKey("memory")) {
        foreach ($plugin in $Config.AnalysisResults["memory"].Keys) {
            $pluginName = $plugin -replace "windows.", ""
            $pluginContent = Get-Content -Path $Config.AnalysisResults["memory"][$plugin] -Raw
            $content += "<h3>$pluginName</h3><pre>$pluginContent</pre>"
        }
    } else {
        $content += "<p>No malware/memory analysis data available.</p>"
    }
    $content += "</div>"
    
    # Network Analysis
    $content += "<div class='section'><h2>Network Analysis</h2>"
    if ($Config.AnalysisResults.ContainsKey("network")) {
        foreach ($plugin in $Config.AnalysisResults["network"].Keys) {
            $pluginName = $plugin -replace "windows.", ""
            $pluginContent = Get-Content -Path $Config.AnalysisResults["network"][$plugin] -Raw
            $content += "<h3>$pluginName</h3><pre>$pluginContent</pre>"
        }
    } else {
        $content += "<p>No network analysis data available.</p>"
    }
    $content += "</div>"
    
    # Registry Analysis
    $content += "<div class='section'><h2>Registry Analysis</h2>"
    if ($Config.AnalysisResults.ContainsKey("registry")) {
        foreach ($plugin in $Config.AnalysisResults["registry"].Keys) {
            $pluginName = $plugin -replace "windows.", ""
            $pluginContent = Get-Content -Path $Config.AnalysisResults["registry"][$plugin] -Raw
            $content += "<h3>$pluginName</h3><pre>$pluginContent</pre>"
        }
    } else {
        $content += "<p>No registry analysis data available.</p>"
    }
    $content += "</div>"
    
    # Generate final report
    Export-HTMLReport -Config $Config -Title "Memory Forensics Analysis Report" -Content $content -OutputFile $reportFile
    
    # Open the report
    try {
        Start-Process $reportFile
    } catch {
        Write-Host "Report saved to $reportFile. Unable to open automatically." -ForegroundColor Yellow
    }
}

function Export-CSVReport {
    param (
        [Parameter(Mandatory = $true)]
        [string]$InputFile,
        
        [Parameter(Mandatory = $true)]
        [string]$OutputFile,
        
        [Parameter(Mandatory = $false)]
        [string]$Delimiter = ","
    )
    
    try {
        $content = Get-Content -Path $InputFile -Raw
        $lines = $content -split "`n" | Where-Object { $_ -match '\S' }
        
        if ($lines.Count -lt 2) {
            Write-Error "Input file doesn't contain enough data for CSV conversion"
            return
        }
        
        # Extract header
        $header = $lines[0] -replace '^\s+', '' -replace '\s+$', ''
        $headerCols = $header -split '\s{2,}'
        
        # Process data rows
        $data = @()
        for ($i = 1; $i -lt $lines.Count; $i++) {
            $line = $lines[$i] -replace '^\s+', '' -replace '\s+$', ''
            if ($line -match '\S') {
                $cols = $line -split '\s{2,}'
                
                $row = @{}
                for ($j = 0; $j -lt [Math]::Min($headerCols.Count, $cols.Count); $j++) {
                    $row[$headerCols[$j]] = $cols[$j]
                }
                
                $data += [PSCustomObject]$row
            }
        }
        
        # Export to CSV
        $data | Export-Csv -Path $OutputFile -NoTypeInformation -Delimiter $Delimiter
        Write-Host "CSV report saved to: $OutputFile" -ForegroundColor Green
    }
    catch {
        Write-Error "Error creating CSV report: $_"
    }
}

function Export-JsonReport {
    param (
        [Parameter(Mandatory = $true)]
        [string]$InputFile,
        
        [Parameter(Mandatory = $true)]
        [string]$OutputFile
    )
    
    try {
        $content = Get-Content -Path $InputFile -Raw
        $lines = $content -split "`n" | Where-Object { $_ -match '\S' }
        
        if ($lines.Count -lt 2) {
            Write-Error "Input file doesn't contain enough data for JSON conversion"
            return
        }
        
        # Extract header
        $header = $lines[0] -replace '^\s+', '' -replace '\s+$', ''
        $headerCols = $header -split '\s{2,}'
        
        # Process data rows
        $data = @()
        for ($i = 1; $i -lt $lines.Count; $i++) {
            $line = $lines[$i] -replace '^\s+', '' -replace '\s+$', ''
            if ($line -match '\S') {
                $cols = $line -split '\s{2,}'
                
                $row = @{}
                for ($j = 0; $j -lt [Math]::Min($headerCols.Count, $cols.Count); $j++) {
                    $row[$headerCols[$j]] = $cols[$j]
                }
                
                $data += [PSCustomObject]$row
            }
        }
        
        # Export to JSON
        $data | ConvertTo-Json | Out-File -FilePath $OutputFile -Encoding utf8
        Write-Host "JSON report saved to: $OutputFile" -ForegroundColor Green
    }
    catch {
        Write-Error "Error creating JSON report: $_"
    }
} 